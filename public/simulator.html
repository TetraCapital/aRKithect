<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Room Simulator — aRKithect</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #0e0e0d; --panel: #161614; --panel2: #1e1e1b;
  --border: #2a2a26; --text: #e8e4dc; --muted: #6b6860;
  --accent: #c8a96e; --accent2: #8fbcbb; --red: #e06060;
}
html, body { height: 100%; overflow: hidden; }
body { background: var(--bg); color: var(--text); font-family: 'DM Sans', sans-serif; font-weight: 300; display: flex; flex-direction: column; }

.topbar { height: 52px; background: var(--panel); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 20px; gap: 0; flex-shrink: 0; z-index: 100; }
.topbar-logo { font-family: 'Cormorant Garamond', serif; font-size: 18px; font-weight: 600; color: var(--text); text-decoration: none; margin-right: 32px; }
.topbar-logo span { color: var(--accent); }
.topbar-back { font-size: 12px; letter-spacing: .12em; text-transform: uppercase; color: var(--muted); text-decoration: none; margin-right: 32px; transition: color .2s; }
.topbar-back:hover { color: var(--text); }
.topbar-title { font-size: 13px; color: var(--muted); }
.view-toggle { margin-left: auto; display: flex; gap: 2px; background: var(--bg); padding: 4px; border-radius: 4px; }
.view-btn { padding: 6px 16px; font-size: 12px; letter-spacing: .1em; text-transform: uppercase; background: transparent; color: var(--muted); border: none; cursor: pointer; border-radius: 3px; font-family: 'DM Sans', sans-serif; transition: all .15s; }
.view-btn.active { background: var(--panel2); color: var(--accent); }

.app-body { display: flex; flex: 1; overflow: hidden; }

.left-panel { width: 270px; flex-shrink: 0; background: var(--panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
.panel-tabs { display: flex; border-bottom: 1px solid var(--border); }
.panel-tab { flex: 1; padding: 11px 4px; font-size: 10px; letter-spacing: .1em; text-transform: uppercase; background: transparent; color: var(--muted); border: none; cursor: pointer; font-family: 'DM Sans', sans-serif; border-bottom: 2px solid transparent; transition: all .15s; margin-bottom: -1px; }
.panel-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.panel-content { flex: 1; overflow-y: auto; padding: 14px; }
.panel-content::-webkit-scrollbar { width: 4px; }
.panel-content::-webkit-scrollbar-thumb { background: var(--border); }
.tab-pane { display: none; }
.tab-pane.active { display: block; }

.section-head { font-size: 10px; letter-spacing: .15em; text-transform: uppercase; color: var(--accent); margin: 14px 0 10px; padding-bottom: 5px; border-bottom: 1px solid var(--border); }
.section-head:first-child { margin-top: 0; }
.field-label { font-size: 10px; letter-spacing: .12em; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; display: block; }
.field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 7px; }
.field-row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
.input-wrap { position: relative; margin-bottom: 8px; }
.input-wrap input[type="number"], select { width: 100%; background: var(--panel2); border: 1px solid var(--border); color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 13px; font-weight: 300; padding: 7px 28px 7px 10px; outline: none; border-radius: 3px; transition: border-color .15s; appearance: none; }
.input-wrap input:focus, select:focus { border-color: var(--accent); }
.input-unit { position: absolute; right: 9px; top: 50%; transform: translateY(-50%); font-size: 10px; color: var(--muted); pointer-events: none; }
input[type="color"] { width: 100%; height: 34px; background: var(--panel2); border: 1px solid var(--border); cursor: pointer; border-radius: 3px; padding: 3px; }
input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; }
.small-label { font-size: 10px; color: var(--muted); text-align: center; display: block; margin-top: 2px; }

.wall-selector { display: grid; grid-template-columns: repeat(2,1fr); gap: 5px; margin-bottom: 10px; }
.wall-btn { padding: 7px 5px; font-size: 11px; background: var(--panel2); border: 1px solid var(--border); color: var(--muted); cursor: pointer; border-radius: 3px; font-family: 'DM Sans', sans-serif; transition: all .15s; text-align: center; }
.wall-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(200,169,110,.08); }

.apply-btn { width: 100%; padding: 9px; background: var(--accent); color: #111; border: none; cursor: pointer; font-family: 'DM Sans', sans-serif; font-size: 11px; letter-spacing: .12em; text-transform: uppercase; font-weight: 500; border-radius: 3px; transition: opacity .15s; margin-top: 8px; }
.apply-btn:hover { opacity: .85; }
.apply-btn.secondary { background: var(--panel2); color: var(--text); border: 1px solid var(--border); }
.apply-btn.danger { background: rgba(224,96,96,.12); color: var(--red); border: 1px solid rgba(224,96,96,.3); }

.swatch-grid { display: grid; grid-template-columns: repeat(4,1fr); gap: 5px; margin-bottom: 8px; }
.swatch { aspect-ratio: 1; border-radius: 3px; cursor: pointer; border: 2px solid transparent; transition: border-color .15s, transform .1s; }
.swatch:hover { transform: scale(1.06); }
.swatch.selected { border-color: var(--accent); }
.swatch[data-texture="plain"]    { background: var(--c,#e8e4dc); }
.swatch[data-texture="wood"]     { background: repeating-linear-gradient(90deg,var(--c,#8B6914) 0px,var(--c,#8B6914) 8px,color-mix(in srgb,var(--c,#8B6914) 70%,#000) 8px,color-mix(in srgb,var(--c,#8B6914) 70%,#000) 10px); }
.swatch[data-texture="tile"]     { background: repeating-conic-gradient(var(--c,#e0ddd8) 0% 25%,color-mix(in srgb,var(--c,#e0ddd8) 85%,#000) 0% 50%) 0 0/16px 16px; }
.swatch[data-texture="brick"]    { background-color:var(--c,#b5614a); background-image:repeating-linear-gradient(0deg,transparent,transparent 8px,rgba(0,0,0,.15) 8px,rgba(0,0,0,.15) 10px),repeating-linear-gradient(90deg,rgba(0,0,0,.1) 0,rgba(0,0,0,.1) 1px,transparent 1px,transparent 20px); }
.swatch[data-texture="concrete"] { background-color:var(--c,#9a9890); }

/* WALL DROPDOWN */
.wall-dropdown-wrap { position: relative; margin-bottom: 10px; }
.wall-dropdown-btn {
  width: 100%; padding: 8px 10px; background: var(--panel2);
  border: 1px solid var(--border); color: var(--text);
  border-radius: 3px; cursor: pointer; display: flex;
  justify-content: space-between; align-items: center;
  font-size: 13px; transition: border-color .15s;
}
.wall-dropdown-btn:hover { border-color: var(--accent); }
.wall-dd-arrow { color: var(--muted); font-size: 10px; }
.wall-dropdown-list {
  display: none; position: absolute; top: calc(100% + 3px); left: 0; right: 0;
  background: var(--panel); border: 1px solid var(--border);
  border-radius: 3px; z-index: 200; box-shadow: 0 8px 24px rgba(0,0,0,.4);
  max-height: 220px; overflow-y: auto;
}
.wall-dropdown-list.open { display: block; }
.wall-dd-item {
  padding: 8px 12px; font-size: 12px; color: var(--text);
  cursor: pointer; display: flex; justify-content: space-between;
  align-items: center; transition: background .1s;
}
.wall-dd-item:hover { background: var(--panel2); color: var(--accent); }
.wall-dd-item.active { color: var(--accent); }
.wall-dd-len { font-size: 10px; color: var(--muted); }


.room-type-sel { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 12px; }
.room-type-btn { padding: 8px 4px; font-size: 10px; letter-spacing: .1em; text-transform: uppercase; background: var(--panel2); border: 1px solid var(--border); color: var(--muted); cursor: pointer; border-radius: 3px; font-family: 'DM Sans', sans-serif; text-align: center; transition: all .15s; }
.room-type-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(200,169,110,.08); }
.furniture-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.furn-item { padding: 8px 6px; background: var(--panel2); border: 1px solid var(--border); border-radius: 3px; cursor: pointer; text-align: center; transition: all .15s; user-select: none; }
.furn-item:hover { border-color: var(--accent); background: rgba(200,169,110,.06); }
.furn-icon { font-size: 22px; display: block; margin-bottom: 4px; }
.furn-label { font-size: 10px; color: var(--muted); }
.furn-hint { font-size: 10px; color: var(--muted); margin-top: 8px; line-height: 1.6; }

/* CANVAS */
.canvas-area { flex: 1; position: relative; overflow: hidden; display: flex; flex-direction: column; }
.canvas-toolbar { height: 40px; background: var(--panel); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 14px; gap: 6px; flex-shrink: 0; }
.tool-btn { padding: 5px 11px; font-size: 11px; background: transparent; color: var(--muted); border: 1px solid transparent; cursor: pointer; border-radius: 3px; font-family: 'DM Sans', sans-serif; letter-spacing: .08em; text-transform: uppercase; transition: all .15s; }
.tool-btn.active { background: var(--panel2); border-color: var(--border); color: var(--accent); }
.tool-btn:hover:not(.active) { color: var(--text); }
.tool-sep { width: 1px; height: 20px; background: var(--border); margin: 0 3px; }
.tool-info { margin-left: auto; font-size: 11px; color: var(--muted); }
.snap-badge { background: rgba(200,169,110,.15); color: var(--accent); font-size: 10px; padding: 2px 7px; border-radius: 10px; border: 1px solid rgba(200,169,110,.3); display: none; }
.snap-badge.visible { display: inline-block; }

.view-2d, .view-3d { position: absolute; top: 40px; left: 0; right: 0; bottom: 0; }
.view-3d { display: none; }
#canvas2d { position: absolute; inset: 0; display: block; }
#canvas3d { position: absolute; inset: 0; width: 100%; height: 100%; }
#canvas3d canvas { display: block; width: 100% !important; height: 100% !important; }

.canvas-hint { position: absolute; bottom: 14px; left: 50%; transform: translateX(-50%); background: rgba(14,14,13,.72); border: 1px solid var(--border); padding: 7px 16px; font-size: 11px; color: #ccc; border-radius: 20px; backdrop-filter: blur(8px); pointer-events: none; white-space: nowrap; z-index: 10; }

/* CONTEXT MENU */
.ctx-menu { position: fixed; background: var(--panel); border: 1px solid var(--border); border-radius: 4px; z-index: 500; min-width: 150px; box-shadow: 0 8px 24px rgba(0,0,0,.4); display: none; }
.ctx-menu.visible { display: block; }
.ctx-item { padding: 9px 14px; font-size: 12px; color: var(--text); cursor: pointer; transition: background .1s; }
.ctx-item:hover { background: var(--panel2); }
.ctx-item.danger { color: var(--red); }
.ctx-sep { height: 1px; background: var(--border); margin: 3px 0; }

/* RIGHT PANEL */
.right-panel { width: 190px; flex-shrink: 0; background: var(--panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
.right-panel-head { padding: 11px 14px; font-size: 10px; letter-spacing: .15em; text-transform: uppercase; color: var(--muted); border-bottom: 1px solid var(--border); flex-shrink: 0; }
.right-panel-body { flex: 1; overflow-y: auto; padding: 11px; }
.right-panel-body::-webkit-scrollbar { width: 4px; }
.right-panel-body::-webkit-scrollbar-thumb { background: var(--border); }
.room-prop { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border); }
.room-prop:last-child { border-bottom: none; }
.room-prop-label { font-size: 10px; color: var(--muted); letter-spacing: .1em; text-transform: uppercase; margin-bottom: 3px; }
.room-prop-value { font-size: 15px; color: var(--text); font-family: 'Cormorant Garamond', serif; }
.room-prop-unit { font-size: 11px; color: var(--muted); }
.surface-preview-list { display: flex; flex-direction: column; gap: 5px; }
.surface-item { display: flex; align-items: center; gap: 7px; padding: 5px 7px; border-radius: 3px; background: var(--panel2); border: 1px solid var(--border); }
.surface-dot { width: 18px; height: 18px; border-radius: 2px; flex-shrink: 0; }
.surface-name { font-size: 11px; color: var(--text); }
.surface-mat { font-size: 10px; color: var(--muted); }
</style>
</head>
<body>

<div class="topbar">
  <a href="/" class="topbar-logo">a<span>RK</span>ithect</a>
  <a href="/" class="topbar-back">← Portfolio</a>
  <span class="topbar-title">Room Simulator</span>
  <div class="view-toggle">
    <button class="view-btn active" id="btn2d" onclick="switchView('2d')">2D Plan</button>
    <button class="view-btn" id="btn3d" onclick="switchView('3d')">3D View</button>
  </div>
</div>

<div class="app-body">
  <div class="left-panel">
    <div class="panel-tabs">
      <button class="panel-tab active" onclick="switchTab('room',this)">Room</button>
      <button class="panel-tab" onclick="switchTab('surfaces',this)">Surfaces</button>
      <button class="panel-tab" onclick="switchTab('furniture',this)">Furniture</button>
    </div>
    <div class="panel-content">

      <!-- ROOM TAB -->
      <div class="tab-pane active" id="tab-room">
        <div class="section-head">Shape — drag corners to reshape</div>
        <p style="font-size:11px;color:var(--muted);line-height:1.6;margin-bottom:10px;">Drag any corner point to reshape the room. Right-click a wall segment to add a corner (create L-shapes etc). Angles snap to 90° automatically.</p>
        <button class="apply-btn secondary" onclick="resetToRect()">↺ Reset to Rectangle</button>

        <div class="section-head">Ceiling Height</div>
        <div class="input-wrap">
          <input type="number" id="roomH" value="2.6" min="1.8" max="6" step="0.05" oninput="updateHeight()">
          <span class="input-unit">m</span>
        </div>

        <div class="section-head">Add Door</div>
        <div class="field-label">Wall</div>
        <div class="wall-dropdown-wrap" id="door-wall-wrap">
          <div class="wall-dropdown-btn" id="door-wall-btn" onclick="toggleWallDropdown('door')">
            <span id="door-wall-label">Wall 1</span><span class="wall-dd-arrow">▾</span>
          </div>
          <div class="wall-dropdown-list" id="door-wall-list"></div>
        </div>
        <div class="field-row">
          <div class="input-wrap"><input type="number" id="doorW" value="0.9" min="0.5" max="2.4" step="0.05"><span class="input-unit">m</span></div>
          <div class="input-wrap"><input type="number" id="doorH" value="2.1" min="1.5" max="2.8" step="0.05"><span class="input-unit">m</span></div>
        </div>
        <div style="display:flex;gap:4px;"><span class="small-label" style="flex:1">Width</span><span class="small-label" style="flex:1">Height</span></div>
        <div style="margin-top:10px;">
          <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--muted);margin-bottom:4px;"><span>Position</span><span id="doorPosV">50%</span></div>
          <input type="range" id="doorPos" min="5" max="95" value="50" oninput="document.getElementById('doorPosV').textContent=this.value+'%'">
        </div>
        <button class="apply-btn secondary" onclick="addOpening('door')">+ Add Door</button>

        <div class="section-head">Add Window</div>
        <div class="field-label">Wall</div>
        <div class="wall-dropdown-wrap" id="window-wall-wrap">
          <div class="wall-dropdown-btn" id="window-wall-btn" onclick="toggleWallDropdown('window')">
            <span id="window-wall-label">Wall 1</span><span class="wall-dd-arrow">▾</span>
          </div>
          <div class="wall-dropdown-list" id="window-wall-list"></div>
        </div>
        <div class="field-row-3">
          <div class="input-wrap"><input type="number" id="winW" value="1.2" min="0.3" max="3" step="0.1"><span class="input-unit">m</span></div>
          <div class="input-wrap"><input type="number" id="winH" value="1.0" min="0.3" max="2.2" step="0.1"><span class="input-unit">m</span></div>
          <div class="input-wrap"><input type="number" id="winSill" value="0.9" min="0" max="2" step="0.05"><span class="input-unit">m</span></div>
        </div>
        <div style="display:flex;gap:4px;"><span class="small-label" style="flex:1">W</span><span class="small-label" style="flex:1">H</span><span class="small-label" style="flex:1">Sill</span></div>
        <div style="margin-top:10px;">
          <div style="display:flex;justify-content:space-between;font-size:10px;color:var(--muted);margin-bottom:4px;"><span>Position</span><span id="winPosV">50%</span></div>
          <input type="range" id="winPos" min="5" max="95" value="50" oninput="document.getElementById('winPosV').textContent=this.value+'%'">
        </div>
        <button class="apply-btn secondary" onclick="addOpening('window')">+ Add Window</button>

        <div class="section-head">Inner Walls</div>
        <p style="font-size:11px;color:var(--muted);line-height:1.6;margin-bottom:8px;">Select "Draw Wall" tool, then click two points inside the room.</p>
        <div id="inner-walls-list"><span style="font-size:11px;color:var(--muted);">None yet.</span></div>

        <div class="section-head">Openings</div>
        <div id="openings-list"><span style="font-size:11px;color:var(--muted);">None yet.</span></div>
      </div>

      <!-- SURFACES TAB -->
      <div class="tab-pane" id="tab-surfaces">
        <div class="section-head">Select Surface</div>
        <div class="wall-selector" style="grid-template-columns:repeat(2,1fr)">
          <button class="wall-btn active" onclick="selectSurface('floor',this)">Floor</button>
          <button class="wall-btn" onclick="selectSurface('ceiling',this)">Ceiling</button>
          <button class="wall-btn" onclick="selectSurface('all-walls',this)" style="grid-column:span 2">All Walls</button>
        </div>
        <div class="wall-dropdown-wrap" id="surface-wall-wrap" style="margin-bottom:10px;">
          <div class="wall-dropdown-btn" id="surface-wall-btn" onclick="toggleWallDropdown('surface')">
            <span id="surface-wall-label">Wall 1</span><span class="wall-dd-arrow">▾</span>
          </div>
          <div class="wall-dropdown-list" id="surface-wall-list"></div>
        </div>
        <div class="section-head">Material</div>
        <div class="input-wrap" style="margin-bottom:10px;">
          <select id="mat-type" onchange="updateSwatches()">
            <option value="plain">Plain / Paint</option>
            <option value="wood">Wood</option>
            <option value="tile">Tile</option>
            <option value="brick">Brick</option>
            <option value="concrete">Concrete</option>
          </select>
        </div>
        <div class="section-head">Colour</div>
        <div class="swatch-grid" id="swatch-grid"></div>
        <div class="input-wrap" style="margin-top:6px;">
          <label class="field-label">Custom</label>
          <input type="color" id="custom-color" value="#c8a96e" oninput="selectCustomColor(this.value)">
        </div>
        <div style="margin-top:8px;">
          <label class="field-label">Roughness</label>
          <input type="range" id="roughness" min="0" max="1" step="0.05" value="0.7" oninput="applyCurrentSurface()">
        </div>
        <button class="apply-btn" onclick="applyCurrentSurface()">Apply</button>
        <button class="apply-btn secondary" style="margin-top:5px;" onclick="applyToAll()">Apply to All Walls</button>
      </div>

      <!-- FURNITURE TAB -->
      <div class="tab-pane" id="tab-furniture">
        <div class="section-head">Room Type</div>
        <div class="room-type-sel">
          <button class="room-type-btn active" onclick="setRoomType('bathroom',this)">Bathroom</button>
          <button class="room-type-btn" onclick="setRoomType('kitchen',this)">Kitchen</button>
          <button class="room-type-btn" onclick="setRoomType('living',this)">Living</button>
          <button class="room-type-btn" onclick="setRoomType('bedroom',this)">Bedroom</button>
        </div>
        <div class="section-head">Add Furniture</div>
        <div class="furniture-grid" id="furn-grid"></div>
        <p class="furn-hint">Click item to add · Drag to position · R to rotate · Del to remove</p>
        <div class="section-head">Placed Items</div>
        <div id="furn-list"><span style="font-size:11px;color:var(--muted);">None placed.</span></div>
      </div>

    </div>
  </div>

  <!-- CANVAS AREA -->
  <div class="canvas-area">
    <div class="canvas-toolbar" id="toolbar2d">
      <button class="tool-btn active" id="tool-select" onclick="setTool('select')">Select</button>
      <button class="tool-btn" id="tool-pan" onclick="setTool('pan')">Pan</button>
      <button class="tool-btn" id="tool-wall" onclick="setTool('wall')">Draw Wall</button>
      <div class="tool-sep"></div>
      <button class="tool-btn" onclick="resetView()">Reset View</button>
      <button class="tool-btn" id="tool-grid" onclick="toggleGrid()">Grid: On</button>
      <span class="snap-badge" id="snap-badge">⊙ Snapped</span>
      <span class="tool-info" id="tool-info">Select tool active</span>
    </div>
    <div class="view-2d" id="view2d">
      <canvas id="canvas2d"></canvas>
      <div class="canvas-hint" id="hint2d">Drag corners to reshape · Right-click wall to add corner · Scroll to zoom</div>
    </div>
    <div class="view-3d" id="view3d">
      <div id="canvas3d"></div>
      <canvas id="compass3d" style="position:absolute;top:16px;right:16px;width:72px;height:72px;pointer-events:none;z-index:10;"></canvas>
      <div class="canvas-hint">Left-drag: orbit · Scroll: zoom · Right-drag: pan</div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="right-panel">
    <div class="right-panel-head">Room Info</div>
    <div class="right-panel-body">
      <div class="room-prop"><div class="room-prop-label">Floor Area</div><div class="room-prop-value" id="info-area">20.0 <span class="room-prop-unit">m²</span></div></div>
      <div class="room-prop"><div class="room-prop-label">Perimeter</div><div class="room-prop-value" id="info-perim">18.0 <span class="room-prop-unit">m</span></div></div>
      <div class="room-prop"><div class="room-prop-label">Height</div><div class="room-prop-value" id="info-height">2.60 <span class="room-prop-unit">m</span></div></div>
      <div class="room-prop"><div class="room-prop-label">Wall Area</div><div class="room-prop-value" id="info-wallarea">46.8 <span class="room-prop-unit">m²</span></div></div>
      <div class="room-prop"><div class="room-prop-label">Openings</div><div class="room-prop-value" id="info-openings">0</div></div>
      <div class="room-prop"><div class="room-prop-label">Furniture</div><div class="room-prop-value" id="info-furn">0</div></div>
      <div style="font-size:10px;letter-spacing:.12em;text-transform:uppercase;color:var(--muted);margin:8px 0 6px;">Surfaces</div>
      <div class="surface-preview-list" id="surface-list"></div>
    </div>
  </div>
</div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctx-menu">
  <div class="ctx-item" id="ctx-add-corner" onclick="ctxAddCorner()">✂ Split wall here</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item danger" id="ctx-del-corner" onclick="ctxDelCorner()">× Remove corner</div>
</div>

<script>
// ================================================
// STATE
// ================================================
var H_CEIL = 2.6;

// Room polygon — array of {x,y} in metres
var corners = [
  {x:0, y:0}, {x:5, y:0}, {x:5, y:4}, {x:0, y:4}
];

var openings   = [];   // {wallIdx, type, width, height, sill, position, id}
var innerWalls = [];   // {ax,ay,bx,by}
var furniture  = [];   // {type,x,y,rot,w,d, id, label}

var surfaces = {
  floor:   {color:'#c8b89a', material:'wood',  roughness:0.8},
  ceiling: {color:'#f0ede8', material:'plain', roughness:0.9},
};
// wall-0 .. wall-N generated dynamically
function ensureWallSurfaces() {
  for (var i = 0; i < corners.length; i++) {
    var k = 'wall-' + i;
    if (!surfaces[k]) surfaces[k] = {color:'#e8e4dc', material:'plain', roughness:0.85};
  }
}

var activeSurface  = 'floor';
var selectedColor  = '#c8b89a';
var currentView    = '2d';
var tool           = 'select';
var showGrid       = true;
var doorWallIdx    = 0;
var windowWallIdx  = 0;
var selectedFurnId = null;
var roomType       = 'bathroom';
var hoveredWallIdx = -1;  // for dropdown highlight

// View transform
var view = {x:0, y:0, scale:70};

// Interaction state
var draggingCornerIdx  = -1;
var draggingFurnId     = null;
var furnDragOffset      = {x:0, y:0};
var isRightDrag         = false;
var rightDragStart      = {x:0, y:0};
var wallDrawStart       = null;   // {x,y} in world when drawing inner wall
var snapActive          = false;
var ctxCornerIdx        = -1;
var ctxWallIdx          = -1;
var ctxWallT            = 0;

// ================================================
// CANVAS SETUP
// ================================================
var c2d = document.getElementById('canvas2d');
var ctx = c2d.getContext('2d');

function resizeCanvas() {
  var area = document.getElementById('view2d');
  c2d.width  = area.clientWidth;
  c2d.height = area.clientHeight;
  centreViewOnRoom();
  draw2D();
}

function W2S(wx, wy) {  // world → screen
  return {
    x: c2d.width  / 2 + wx * view.scale + view.x,
    y: c2d.height / 2 + wy * view.scale + view.y
  };
}
function S2W(sx, sy) {  // screen → world
  return {
    x: (sx - c2d.width /2 - view.x) / view.scale,
    y: (sy - c2d.height/2 - view.y) / view.scale
  };
}
function px(v) { return v * view.scale; }

// ================================================
// SNAPPING
// ================================================
var SNAP_ANGLE_DEG = 5;   // snap to 90° increments if within 5°
var SNAP_LEN_CM    = 5;   // snap to nearest 0.5m if within 5cm

function snapPoint(wx, wy, refIdx) {
  snapActive = false;
  var sx = wx, sy = wy;

  // Snap to grid (0.5m)
  var gs = 0.5;
  var nx = Math.round(wx / gs) * gs;
  var ny = Math.round(wy / gs) * gs;
  if (Math.abs(wx - nx) < SNAP_LEN_CM/100) { sx = nx; snapActive = true; }
  if (Math.abs(wy - ny) < SNAP_LEN_CM/100) { sy = ny; snapActive = true; }

  // Snap angle to 90° relative to neighbours
  if (refIdx >= 0) {
    var n = corners.length;
    var prev = corners[(refIdx - 1 + n) % n];
    var next = corners[(refIdx + 1) % n];

    // Try to make right angle with prev
    var dx = sx - prev.x, dy = sy - prev.y;
    var angle = Math.atan2(dy, dx);
    var snapped = Math.round(angle / (Math.PI/2)) * (Math.PI/2);
    if (Math.abs(angle - snapped) < (SNAP_ANGLE_DEG * Math.PI / 180)) {
      var len = Math.sqrt(dx*dx + dy*dy);
      sx = prev.x + Math.cos(snapped) * len;
      sy = prev.y + Math.sin(snapped) * len;
      snapActive = true;
    }
  }

  document.getElementById('snap-badge').classList.toggle('visible', snapActive);
  return {x: sx, y: sy};
}

// ================================================
// 2D DRAW
// ================================================
function draw2D() {
  ctx.clearRect(0, 0, c2d.width, c2d.height);
  // Light background matching 3D scene
  ctx.fillStyle = '#d8e4ec';
  ctx.fillRect(0, 0, c2d.width, c2d.height);
  ensureWallSurfaces();

  // Grid
  if (showGrid) {
    ctx.strokeStyle = 'rgba(150,170,190,0.35)'; ctx.lineWidth = 0.5;
    var step = view.scale;
    var ox0 = ((c2d.width/2 + view.x) % step + c2d.width * 3) % step;
    var oy0 = ((c2d.height/2 + view.y) % step + c2d.height * 3) % step;
    for (var gx = ox0 - step; gx < c2d.width + step; gx += step) {
      ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx, c2d.height); ctx.stroke();
    }
    for (var gy = oy0 - step; gy < c2d.height + step; gy += step) {
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(c2d.width, gy); ctx.stroke();
    }
  }

  if (corners.length < 3) return;

  // Floor fill
  ctx.beginPath();
  var s0 = W2S(corners[0].x, corners[0].y);
  ctx.moveTo(s0.x, s0.y);
  for (var i = 1; i < corners.length; i++) {
    var si = W2S(corners[i].x, corners[i].y);
    ctx.lineTo(si.x, si.y);
  }
  ctx.closePath();
  ctx.fillStyle = surfaces.floor.color + 'cc';
  ctx.fill();

  // Floor texture lines
  drawFloorTexture();

  // Walls (thick stroke)
  var wt = Math.max(6, px(0.18));
  for (var wi = 0; wi < corners.length; wi++) {
    var A = W2S(corners[wi].x, corners[wi].y);
    var B = W2S(corners[(wi+1)%corners.length].x, corners[(wi+1)%corners.length].y);
    var wsurf = surfaces['wall-' + wi] || surfaces['wall-0'];
    ctx.strokeStyle = wsurf.color;
    ctx.lineWidth = wt;
    ctx.lineCap = 'square';
    ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
    ctx.strokeStyle = '#3a3a36'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
  }

  // Hovered wall highlight (green, for dropdown)
  if (hoveredWallIdx >= 0 && hoveredWallIdx < corners.length) {
    var hA = W2S(corners[hoveredWallIdx].x, corners[hoveredWallIdx].y);
    var hB = W2S(corners[(hoveredWallIdx+1)%corners.length].x, corners[(hoveredWallIdx+1)%corners.length].y);
    ctx.save();
    ctx.strokeStyle = '#5fcf80'; ctx.lineWidth = wt + 4; ctx.lineCap = 'square';
    ctx.globalAlpha = 0.7;
    ctx.beginPath(); ctx.moveTo(hA.x, hA.y); ctx.lineTo(hB.x, hB.y); ctx.stroke();
    ctx.restore();
  }

  // Openings
  drawOpenings2D(wt);

  // Inner walls
  innerWalls.forEach(function(iw) {
    var A = W2S(iw.ax, iw.ay), B = W2S(iw.bx, iw.by);
    ctx.strokeStyle = '#888'; ctx.lineWidth = wt * 0.7; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
    ctx.strokeStyle = '#3a3a36'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
  });

  // Furniture
  drawFurniture2D();

  // Corner handles
  corners.forEach(function(c, idx) {
    var sp = W2S(c.x, c.y);
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 7, 0, Math.PI*2);
    ctx.fillStyle   = idx === draggingCornerIdx ? '#c8a96e' : '#d8e4ec';
    ctx.strokeStyle = '#c8a96e'; ctx.lineWidth = 2;
    ctx.fill(); ctx.stroke();
  });

  // Wall-draw preview
  if (tool === 'wall' && wallDrawStart) {
    // drawn in mousemove via drawWallPreview
  }

  // Dimension labels
  drawDimensions();

  // Compass
  drawCompass();

  updateInfoPanel();
}

function drawFloorTexture() {
  var mat = surfaces.floor.material;
  if (mat !== 'wood' && mat !== 'tile') return;
  ctx.save();
  ctx.beginPath();
  var s0 = W2S(corners[0].x, corners[0].y);
  ctx.moveTo(s0.x, s0.y);
  corners.slice(1).forEach(function(c) { var sp = W2S(c.x,c.y); ctx.lineTo(sp.x, sp.y); });
  ctx.closePath(); ctx.clip();
  ctx.globalAlpha = 0.18; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 0.5;
  var step = mat === 'wood' ? px(0.12) : px(0.3);
  var bounds = getBounds();
  var A = W2S(bounds.minX, bounds.minY), B = W2S(bounds.maxX, bounds.maxY);
  for (var x = A.x; x < B.x + step; x += step) {
    ctx.beginPath(); ctx.moveTo(x, A.y); ctx.lineTo(x, B.y); ctx.stroke();
  }
  if (mat === 'tile') {
    for (var y = A.y; y < B.y + step; y += step) {
      ctx.beginPath(); ctx.moveTo(A.x, y); ctx.lineTo(B.x, y); ctx.stroke();
    }
  }
  ctx.restore();
}

function getBounds() {
  var xs = corners.map(function(c){return c.x;}), ys = corners.map(function(c){return c.y;});
  return {minX:Math.min.apply(null,xs), maxX:Math.max.apply(null,xs), minY:Math.min.apply(null,ys), maxY:Math.max.apply(null,ys)};
}

function drawOpenings2D(wt) {
  openings.forEach(function(op) {
    var wi = op.wallIdx % corners.length;
    var A = corners[wi], B = corners[(wi+1)%corners.length];
    var len = dist(A, B);
    var t = Math.max(op.width/len/2, Math.min(1 - op.width/len/2, op.position));
    // Centre of opening in world
    var cx = A.x + (B.x-A.x)*t, cy = A.y + (B.y-A.y)*t;
    // Wall direction
    var dx = (B.x-A.x)/len, dy = (B.y-A.y)/len;
    // Screen positions
    var pxW = px(op.width);
    var sA = W2S(cx - dx*op.width/2, cy - dy*op.width/2);
    var sB = W2S(cx + dx*op.width/2, cy + dy*op.width/2);

    // Erase wall segment
    ctx.strokeStyle = '#0e0e0d'; ctx.lineWidth = wt + 2; ctx.lineCap = 'butt';
    ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();

    if (op.type === 'door') {
      ctx.strokeStyle = 'rgba(200,169,110,0.7)'; ctx.lineWidth = 1.5;
      ctx.setLineDash([3,3]);
      var swingR = px(op.width);
      var ang0 = Math.atan2(dy, dx) + Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(sA.x, sA.y);
      ctx.arc(sA.x, sA.y, swingR, ang0, ang0 + Math.PI/2);
      ctx.stroke(); ctx.setLineDash([]);
      ctx.strokeStyle = '#c8a96e'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();
    } else {
      ctx.strokeStyle = '#4a9fb5'; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();
      var mx=(sA.x+sB.x)/2, my=(sA.y+sB.y)/2;
      var nx=-dy*6, ny=dx*6;
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(mx-nx, my-ny); ctx.lineTo(mx+nx, my+ny); ctx.stroke();
    }
  });
}

function drawFurniture2D() {
  furniture.forEach(function(f) {
    var sp = W2S(f.x, f.y);
    var hw = px(f.w)/2, hd = px(f.d)/2;
    var isSelected = f.id === selectedFurnId;

    ctx.save();
    ctx.translate(sp.x, sp.y);
    ctx.rotate(f.rot * Math.PI/2);

    // Shadow
    ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 4; ctx.shadowOffsetY = 2;
    ctx.fillStyle = isSelected ? 'rgba(200,169,110,0.25)' : 'rgba(30,30,27,0.85)';
    ctx.strokeStyle = isSelected ? '#c8a96e' : '#555';
    ctx.lineWidth = isSelected ? 2 : 1;
    ctx.shadowColor = 'transparent';

    // Draw furniture shape
    drawFurnShape(ctx, f.type, hw, hd);

    ctx.restore();

    // Label
    ctx.save();
    ctx.fillStyle = isSelected ? '#c8a96e' : '#6b6860';
    ctx.font = Math.max(9, px(0.14)) + 'px DM Sans';
    ctx.textAlign = 'center';
    ctx.fillText(f.label, sp.x, sp.y + hd + 12);
    ctx.restore();
  });
}

function drawFurnShape(ctx, type, hw, hd) {
  ctx.beginPath();
  ctx.rect(-hw, -hd, hw*2, hd*2);
  ctx.fill(); ctx.stroke();

  ctx.strokeStyle = 'rgba(200,169,110,0.4)'; ctx.lineWidth = 0.5;

  // Interior detail per type
  if (type === 'toilet') {
    ctx.beginPath(); ctx.ellipse(0, hd*0.15, hw*0.7, hd*0.55, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.rect(-hw*0.85, -hd, hw*1.7, hd*0.4); ctx.stroke();
  } else if (type === 'sink') {
    ctx.beginPath(); ctx.ellipse(0, 0, hw*0.65, hd*0.65, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(0, 0, hw*0.12, 0, Math.PI*2); ctx.stroke();
  } else if (type === 'bath') {
    ctx.beginPath(); ctx.roundRect(-hw*0.85, -hd*0.8, hw*1.7, hd*1.5, 8); ctx.stroke();
    ctx.beginPath(); ctx.arc(0, hd*0.4, hw*0.2, 0, Math.PI*2); ctx.stroke();
  } else if (type === 'shower') {
    ctx.beginPath(); ctx.rect(-hw*0.9,-hd*0.9,hw*1.8,hd*1.8); ctx.stroke();
    for (var r=-1;r<=1;r+=1) { for (var c=-1;c<=1;c+=1) { ctx.beginPath(); ctx.arc(r*hw*0.35,c*hd*0.35,1.5,0,Math.PI*2); ctx.fill(); }}
  } else if (type === 'fridge') {
    ctx.beginPath(); ctx.rect(-hw*0.85, -hd+4, hw*1.7, hd*0.5); ctx.stroke();
    ctx.beginPath(); ctx.rect(-hw*0.85, -hd*0.4, hw*1.7, hd*1.25); ctx.stroke();
  } else if (type === 'oven') {
    ctx.beginPath(); ctx.rect(-hw*0.8, -hd*0.8, hw*1.6, hd*0.7); ctx.stroke();
    [-0.35, 0.35].forEach(function(ox) { [-0.35, 0.35].forEach(function(oy) {
      ctx.beginPath(); ctx.arc(ox*hw, oy*hd, hw*0.15, 0, Math.PI*2); ctx.stroke();
    }); });
  } else if (type === 'base-unit') {
    ctx.beginPath(); ctx.moveTo(0,-hd); ctx.lineTo(0, hd); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-hw,0); ctx.lineTo(hw,0); ctx.stroke();
  } else if (type === 'sofa') {
    ctx.beginPath(); ctx.rect(-hw*0.9, -hd*0.9, hw*1.8, hd*0.55); ctx.stroke();
    [-0.55, 0, 0.55].forEach(function(ox) {
      ctx.beginPath(); ctx.rect(ox*hw - hw*0.28, -hd*0.2, hw*0.56, hd*0.9); ctx.stroke();
    });
  } else if (type === 'bed-double') {
    ctx.beginPath(); ctx.rect(-hw*0.9, -hd*0.9, hw*1.8, hd*0.55); ctx.stroke();
    ctx.beginPath(); ctx.rect(-hw*0.85, -hd*0.25, hw*0.8, hd*1.1); ctx.stroke();
    ctx.beginPath(); ctx.rect(hw*0.05, -hd*0.25, hw*0.8, hd*1.1); ctx.stroke();
  } else if (type === 'bed-single') {
    ctx.beginPath(); ctx.rect(-hw*0.9, -hd*0.9, hw*1.8, hd*0.5); ctx.stroke();
    ctx.beginPath(); ctx.rect(-hw*0.85, -hd*0.3, hw*1.7, hd*1.15); ctx.stroke();
  } else if (type === 'desk') {
    ctx.beginPath(); ctx.moveTo(-hw*0.8, hd*0.6); ctx.lineTo(-hw*0.8, -hd*0.6); ctx.stroke();
  } else if (type === 'wardrobe') {
    ctx.beginPath(); ctx.moveTo(0, -hd); ctx.lineTo(0, hd); ctx.stroke();
    ctx.beginPath(); ctx.arc(-hw*0.5, 0, hw*0.08, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc( hw*0.5, 0, hw*0.08, 0, Math.PI*2); ctx.stroke();
  } else if (type === 'dining-table') {
    ctx.beginPath(); ctx.ellipse(0,0,hw*0.85,hd*0.85,0,0,Math.PI*2); ctx.stroke();
  } else if (type === 'island') {
    ctx.beginPath(); ctx.moveTo(-hw*0.9,-hd*0.9); ctx.lineTo(hw*0.9,-hd*0.9); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-hw*0.9, hd*0.9); ctx.lineTo(hw*0.9, hd*0.9); ctx.stroke();
  } else if (type === 'armchair') {
    ctx.beginPath(); ctx.rect(-hw*0.9, -hd*0.9, hw*1.8, hd*0.4); ctx.stroke();
    ctx.beginPath(); ctx.rect(-hw*0.9, -hd*0.9, hw*0.35, hd*1.8); ctx.stroke();
    ctx.beginPath(); ctx.rect( hw*0.55, -hd*0.9, hw*0.35, hd*1.8); ctx.stroke();
  }
}

function drawDimensions() {
  ctx.fillStyle = '#5a6a7a';
  ctx.font = Math.max(10, px(0.16)) + 'px DM Sans';
  ctx.textAlign = 'center';
  for (var i = 0; i < corners.length; i++) {
    var A = corners[i], B = corners[(i+1)%corners.length];
    var len = dist(A,B);
    if (len < 0.3) continue;
    var mx = (A.x+B.x)/2, my = (A.y+B.y)/2;
    var dx = B.x-A.x, dy = B.y-A.y;
    var nx = -dy/len * 0.4, ny = dx/len * 0.4; // offset outward
    var sp = W2S(mx + nx, my + ny);
    ctx.save();
    var angle = Math.atan2(dy, dx);
    if (angle > Math.PI/2 || angle < -Math.PI/2) angle += Math.PI;
    ctx.translate(sp.x, sp.y);
    ctx.rotate(angle);
    ctx.fillText(len.toFixed(2) + ' m', 0, 0);
    ctx.restore();
  }
}

function drawCompass() {
  var cx = c2d.width - 40, cy = 40;
  ctx.save();
  ctx.fillStyle = 'rgba(220,232,240,0.88)';
  ctx.beginPath(); ctx.arc(cx, cy, 24, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(100,120,140,0.4)'; ctx.lineWidth = 1; ctx.stroke();
  ['N','E','S','W'].forEach(function(d,i) {
    var a = i*Math.PI/2 - Math.PI/2;
    ctx.fillStyle = d==='N' ? '#c8a96e' : '#6b7a88';
    ctx.font = (d==='N'?'bold ':'') + '11px DM Sans';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(d, cx + Math.cos(a)*14, cy + Math.sin(a)*14);
  });
  // North arrow
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(-Math.PI/2)*16, cy + Math.sin(-Math.PI/2)*16);
  ctx.strokeStyle = '#c8a96e'; ctx.lineWidth = 2; ctx.lineCap = 'round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2);
  ctx.fillStyle = '#c8a96e'; ctx.fill();
  ctx.restore();
}

// ================================================
// DISTANCE HELPER
// ================================================
function dist(A, B) { return Math.sqrt((B.x-A.x)**2 + (B.y-A.y)**2); }
function distPtSeg(P, A, B) {
  var dx=B.x-A.x, dy=B.y-A.y, l2=dx*dx+dy*dy;
  if (l2===0) return dist(P,A);
  var t=Math.max(0,Math.min(1,((P.x-A.x)*dx+(P.y-A.y)*dy)/l2));
  return dist(P, {x:A.x+t*dx, y:A.y+t*dy});
}

// ================================================
// POLY AREA (shoelace)
// ================================================
function polyArea() {
  var s=0, n=corners.length;
  for(var i=0;i<n;i++){var j=(i+1)%n; s+=corners[i].x*corners[j].y - corners[j].x*corners[i].y;}
  return Math.abs(s/2);
}
function polyPerimeter() {
  var s=0;
  for(var i=0;i<corners.length;i++) s+=dist(corners[i],corners[(i+1)%corners.length]);
  return s;
}

// ================================================
// MOUSE / TOUCH INTERACTION
// ================================================
var HANDLE_RADIUS = 10; // px

function getEventWorld(e) {
  var r = c2d.getBoundingClientRect();
  return S2W(e.clientX - r.left, e.clientY - r.top);
}
function getEventScreen(e) {
  var r = c2d.getBoundingClientRect();
  return {x: e.clientX - r.left, y: e.clientY - r.top};
}

function cornerAtScreen(sx, sy) {
  for (var i = 0; i < corners.length; i++) {
    var sp = W2S(corners[i].x, corners[i].y);
    if (Math.hypot(sp.x - sx, sp.y - sy) < HANDLE_RADIUS + 4) return i;
  }
  return -1;
}

function furnAtWorld(wx, wy) {
  for (var i = furniture.length - 1; i >= 0; i--) {
    var f = furniture[i];
    // Transform point into furniture local space
    var dx = wx - f.x, dy = wy - f.y;
    var cos = Math.cos(-f.rot * Math.PI/2), sin = Math.sin(-f.rot * Math.PI/2);
    var lx = dx*cos - dy*sin, ly = dx*sin + dy*cos;
    if (Math.abs(lx) <= f.w/2 + 0.05 && Math.abs(ly) <= f.d/2 + 0.05) return i;
  }
  return -1;
}

c2d.addEventListener('mousedown', function(e) {
  var ss = getEventScreen(e);
  var ww = S2W(ss.x, ss.y);

  // Right-click or middle-click always pans
  if (e.button === 2 || e.button === 1) {
    isRightDrag = true;
    rightDragStart = {x: e.clientX - view.x, y: e.clientY - view.y};
    e.preventDefault(); return;
  }

  if (tool === 'pan') {
    isRightDrag = true;
    rightDragStart = {x: e.clientX - view.x, y: e.clientY - view.y};
    return;
  }

  if (tool === 'wall') {
    if (!wallDrawStart) {
      wallDrawStart = ww;
    } else {
      innerWalls.push({ax:wallDrawStart.x, ay:wallDrawStart.y, bx:ww.x, by:ww.y});
      wallDrawStart = null;
      draw2D();
      renderInnerWallsList();
    }
    return;
  }

  if (tool === 'select') {
    // Check corner handles first
    var ci = cornerAtScreen(ss.x, ss.y);
    if (ci >= 0) { draggingCornerIdx = ci; return; }

    // Check furniture
    var fi = furnAtWorld(ww.x, ww.y);
    if (fi >= 0) {
      selectedFurnId = furniture[fi].id;
      draggingFurnId  = furniture[fi].id;
      furnDragOffset  = {x: ww.x - furniture[fi].x, y: ww.y - furniture[fi].y};
      draw2D(); return;
    }

    // Nothing hit — pan the view by dragging empty space
    isRightDrag = true;
    rightDragStart = {x: e.clientX - view.x, y: e.clientY - view.y};
    selectedFurnId = null; draw2D();
  }
});

window.addEventListener('mousemove', function(e) {
  if (isRightDrag) {
    view.x = e.clientX - rightDragStart.x;
    view.y = e.clientY - rightDragStart.y;
    draw2D(); return;
  }

  var ww = getEventWorld(e);

  if (draggingCornerIdx >= 0) {
    var snapped = snapPoint(ww.x, ww.y, draggingCornerIdx);
    corners[draggingCornerIdx] = snapped;
    draw2D(); return;
  }

  if (draggingFurnId !== null) {
    var f = furniture.find(function(x){return x.id===draggingFurnId;});
    if (f) {
      f.x = ww.x - furnDragOffset.x;
      f.y = ww.y - furnDragOffset.y;

      // Snap to nearest wall if within 0.25m
      var SNAP_DIST = 0.25;
      var bestDist = SNAP_DIST + 1, bestWall = -1;
      for (var wi2 = 0; wi2 < corners.length; wi2++) {
        var cA = corners[wi2], cB = corners[(wi2+1)%corners.length];
        var d2 = distPtSeg({x:f.x,y:f.y}, cA, cB);
        if (d2 < bestDist) { bestDist = d2; bestWall = wi2; }
      }
      if (bestWall >= 0) {
        var wA = corners[bestWall], wB = corners[(bestWall+1)%corners.length];
        var wdx = wB.x-wA.x, wdy = wB.y-wA.y, wlen = Math.sqrt(wdx*wdx+wdy*wdy);
        // Inward normal: for CCW screen polygon, interior is to the LEFT of travel = (-dy, dx)
        // For CW screen polygon, interior is to the RIGHT = (dy, -dx)
        // polyWindingSign: 1=CW, -1=CCW
        var sign = polyWindingSign();
        var wnx = -wdy/wlen * (-sign);  // negated sign vs previous (was backwards)
        var wny =  wdx/wlen * (-sign);

        // The inward normal points INTO the room. The piece's −hd face should point TOWARD the wall
        // i.e. the −hd face direction = -inward normal = outward normal.
        // angle of outward normal:
        var outAngle = Math.atan2(-wny, -wnx); // angle pointing away from room

        // Per-type: which face offset (in 90° turns) needs to point outward (toward wall)
        // All pieces: wall-face is −hd (top of unrotated drawing) EXCEPT beds (headboard also −hd, same)
        // The −hd face points in the direction of angle = -PI/2 when rot=0 (pointing up = north)
        // After rot r (90° turns CCW), −hd face points at angle: -PI/2 + r*PI/2
        // We want: -PI/2 + r*PI/2 = outAngle
        // → r = (outAngle + PI/2) / (PI/2) = outAngle*2/PI + 1

        // Per-type extra offset so the CORRECT anatomical face hits the wall:
        // toilet: cistern at −hd → offset 0
        // sink: back/pipes at −hd → offset 0
        // bath: tap end is the SHORT side = ±hw, not ±hd. Tap end = −hw face.
        //       −hw face points at angle -PI when rot=0, so we need extra -PI/2 = -1 turn
        // sofa: back rest at −hd → offset 0
        // bed: headboard at −hd*0.9 → that IS the −hd face → offset 0 (fix from before)
        // desk: back at −hd → offset 0
        // armchair: back at −hd → offset 0
        // wardrobe: back at −hd (shallow) → offset 0
        // fridge/oven/base-unit: back at −hd → offset 0
        // island/dining-table: no snap
        var FACE_OFFSET = {
          'bath': -1,  // tap end is the -hw face, needs -90° extra
        };
        var NO_SNAP = { 'island': true, 'dining-table': true };
        if (NO_SNAP[f.type]) { draw2D(); return; }

        var faceOff = FACE_OFFSET[f.type] || 0;
        var rRaw = outAngle * 2 / Math.PI + 1 + faceOff;
        f.rot = ((Math.round(rRaw) % 4) + 4) % 4;

        // Half-depth of the wall-face in piece local space (before rotation)
        // For bath the wall-face is the w side; for all others it's the d side
        var halfD = (f.type === 'bath') ? f.w/2 : f.d/2;

        // Project furniture centre onto wall line, then push inward by halfD
        var t2 = ((f.x-wA.x)*wdx + (f.y-wA.y)*wdy) / (wlen*wlen);
        t2 = Math.max(0.05, Math.min(0.95, t2));
        var projX = wA.x + t2*wdx, projY = wA.y + t2*wdy;
        // Push FROM the wall INTO the room (inward normal direction)
        f.x = projX + wnx * halfD;
        f.y = projY + wny * halfD;
      }

      draw2D();
    }
    return;
  }

  if (tool === 'wall' && wallDrawStart) {
    draw2D();
    var sp = W2S(wallDrawStart.x, wallDrawStart.y);
    var ep = W2S(ww.x, ww.y);
    ctx.strokeStyle = 'rgba(200,169,110,0.7)'; ctx.lineWidth = 3; ctx.setLineDash([6,4]);
    ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(ep.x, ep.y); ctx.stroke();
    ctx.setLineDash([]);
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 5, 0, Math.PI*2);
    ctx.fillStyle = '#c8a96e'; ctx.fill();
  }
});

window.addEventListener('mouseup', function(e) {
  if (e.button === 2) { isRightDrag = false; return; }
  isRightDrag = false;
  draggingCornerIdx = -1;
  draggingFurnId = null;
});

// Right-click on canvas: context menu on wall
c2d.addEventListener('contextmenu', function(e) {
  e.preventDefault();
  var ss = getEventScreen(e);
  var ww = S2W(ss.x, ss.y);

  // Check if near a corner
  var ci = cornerAtScreen(ss.x, ss.y);
  if (ci >= 0) {
    ctxCornerIdx = ci; ctxWallIdx = -1;
    var menu = document.getElementById('ctx-menu');
    document.getElementById('ctx-add-corner').style.display = 'none';
    document.getElementById('ctx-del-corner').style.display = corners.length > 3 ? 'block' : 'none';
    menu.style.left = e.clientX + 'px'; menu.style.top = e.clientY + 'px';
    menu.classList.add('visible'); return;
  }

  // Check if near a wall segment
  for (var wi = 0; wi < corners.length; wi++) {
    var A = corners[wi], B = corners[(wi+1)%corners.length];
    var d = distPtSeg(ww, A, B);
    if (d * view.scale < 10) {
      ctxWallIdx = wi; ctxCornerIdx = -1;
      // Compute t along segment
      var dx=B.x-A.x, dy=B.y-A.y, l2=dx*dx+dy*dy;
      ctxWallT = Math.max(0.1, Math.min(0.9, ((ww.x-A.x)*dx+(ww.y-A.y)*dy)/l2));
      var menu = document.getElementById('ctx-menu');
      document.getElementById('ctx-add-corner').style.display = 'block';
      document.getElementById('ctx-del-corner').style.display = 'none';
      menu.style.left = e.clientX + 'px'; menu.style.top = e.clientY + 'px';
      menu.classList.add('visible'); return;
    }
  }
});


function ctxAddCorner() {
  document.getElementById('ctx-menu').classList.remove('visible');
  if (ctxWallIdx < 0) return;
  var A = corners[ctxWallIdx], B = corners[(ctxWallIdx+1)%corners.length];
  var nx = {x: A.x + (B.x-A.x)*ctxWallT, y: A.y + (B.y-A.y)*ctxWallT};
  corners.splice(ctxWallIdx+1, 0, nx);
  ensureWallSurfaces();
  refreshWallDropdowns();
  draw2D();
}

function ctxDelCorner() {
  document.getElementById('ctx-menu').classList.remove('visible');
  if (ctxCornerIdx < 0 || corners.length <= 3) return;
  corners.splice(ctxCornerIdx, 1);
  openings = openings.filter(function(o){return o.wallIdx < corners.length;});
  ensureWallSurfaces();
  refreshWallDropdowns();
  draw2D();
}

// Keyboard shortcuts
window.addEventListener('keydown', function(e) {
  if (e.target.tagName === 'INPUT') return;
  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedFurnId !== null) {
    furniture = furniture.filter(function(f){return f.id !== selectedFurnId;});
    selectedFurnId = null;
    draw2D(); renderFurnList(); return;
  }
  if (e.key === 'r' || e.key === 'R') {
    if (selectedFurnId !== null) {
      var f = furniture.find(function(x){return x.id===selectedFurnId;});
      if (f) { f.rot = (f.rot + 1) % 4; draw2D(); }
    }
  }
  if (e.key === 'Escape') {
    wallDrawStart = null;
    selectedFurnId = null;
    draw2D();
  }
});

// Scroll zoom
c2d.addEventListener('wheel', function(e) {
  e.preventDefault();
  var factor = e.deltaY > 0 ? 0.9 : 1.1;
  view.scale = Math.max(20, Math.min(300, view.scale * factor));
  draw2D();
}, {passive: false});

// ================================================
// ROOM OPERATIONS
// ================================================
function resetToRect() {
  corners = [{x:0,y:0},{x:5,y:0},{x:5,y:4},{x:0,y:4}];
  openings = []; innerWalls = []; furniture = [];
  surfaces = {
    floor:{color:'#c8b89a',material:'wood',roughness:0.8},
    ceiling:{color:'#f0ede8',material:'plain',roughness:0.9},
  };
  ensureWallSurfaces();
  renderOpeningsList(); renderInnerWallsList(); renderFurnList();
  resetView();
  if (currentView === '3d') buildRoom3D();
}

function updateHeight() {
  H_CEIL = parseFloat(document.getElementById('roomH').value) || 2.6;
  updateInfoPanel();
  if (currentView === '3d') buildRoom3D();
}

function updateInfoPanel() {
  var area  = polyArea();
  var perim = polyPerimeter();
  document.getElementById('info-area').innerHTML   = area.toFixed(1)  + ' <span class="room-prop-unit">m²</span>';
  document.getElementById('info-perim').innerHTML  = perim.toFixed(1) + ' <span class="room-prop-unit">m</span>';
  document.getElementById('info-height').innerHTML = H_CEIL.toFixed(2)+ ' <span class="room-prop-unit">m</span>';
  document.getElementById('info-wallarea').innerHTML = (perim * H_CEIL).toFixed(1) + ' <span class="room-prop-unit">m²</span>';
  document.getElementById('info-openings').textContent = openings.length;
  document.getElementById('info-furn').textContent     = furniture.length;
  updateSurfaceList();
}

function updateSurfaceList() {
  var names = {floor:'Floor',ceiling:'Ceiling'};
  for (var i=0;i<corners.length;i++) names['wall-'+i]='Wall '+(i+1);
  document.getElementById('surface-list').innerHTML = Object.entries(surfaces).map(function(e) {
    var k=e[0],v=e[1];
    return '<div class="surface-item"><div class="surface-dot" style="background:'+v.color+'"></div><div><div class="surface-name">'+(names[k]||k)+'</div><div class="surface-mat">'+v.material+'</div></div></div>';
  }).join('');
}

function centreViewOnRoom() {
  var b = getBounds();
  var roomCx = (b.minX + b.maxX) / 2;
  var roomCy = (b.minY + b.maxY) / 2;
  // Offset so room centre maps to canvas centre
  view.x = -roomCx * view.scale;
  view.y = -roomCy * view.scale;
}

function resetView() {
  view.scale = 70;
  centreViewOnRoom();
  draw2D();
}

// ================================================
// OPENINGS
// ================================================
// ================================================
// WALL DROPDOWNS
// ================================================
function buildWallDropdowns() {
  ['door','window','surface'].forEach(function(type) {
    var list = document.getElementById(type+'-wall-list');
    if (!list) return;
    list.innerHTML = corners.map(function(c, i) {
      var len = dist(corners[i], corners[(i+1)%corners.length]).toFixed(2);
      return '<div class="wall-dd-item" data-idx="'+i+'"'
        + ' onmouseenter="hoverWall('+i+')"'
        + ' onmouseleave="hoverWall(-1)"'
        + ' onclick="selectWallFromDD(\''+type+'\','+i+')">Wall '+(i+1)
        + '<span class="wall-dd-len">'+len+' m</span></div>';
    }).join('');
  });
}

function hoverWall(idx) {
  hoveredWallIdx = idx;
  if (currentView === '3d' && renderer3d) buildRoom3D();
  else draw2D();
}

function toggleWallDropdown(type) {
  ['door','window','surface'].forEach(function(t) {
    if (t !== type) document.getElementById(t+'-wall-list').classList.remove('open');
  });
  var list = document.getElementById(type+'-wall-list');
  list.classList.toggle('open');
  if (list.classList.contains('open')) buildWallDropdowns();
}

function selectWallFromDD(type, idx) {
  hoveredWallIdx = -1;
  document.getElementById(type+'-wall-list').classList.remove('open');
  var label = 'Wall '+(idx+1)+' ('+dist(corners[idx],corners[(idx+1)%corners.length]).toFixed(2)+' m)';
  document.getElementById(type+'-wall-label').textContent = label;
  if (type==='door')    { doorWallIdx   = idx; }
  if (type==='window')  { windowWallIdx = idx; }
  if (type==='surface') { selectSurface('wall-'+idx, null); }
  draw2D();
}

// Close dropdowns on outside click
document.addEventListener('mousedown', function(e) {
  if (!e.target.closest('.wall-dropdown-wrap')) {
    document.querySelectorAll('.wall-dropdown-list').forEach(function(l){l.classList.remove('open');});
    hoveredWallIdx = -1;
  }
  if (!e.target.closest('#ctx-menu')) document.getElementById('ctx-menu').classList.remove('visible');
});

function selWall(type, idx) {
  if (type==='door')   doorWallIdx   = idx;
  if (type==='window') windowWallIdx = idx;
}

// Call after any corner change to keep dropdowns current
function refreshWallDropdowns() {
  // Reset if selected wall no longer exists
  if (doorWallIdx   >= corners.length) doorWallIdx   = 0;
  if (windowWallIdx >= corners.length) windowWallIdx = 0;
  var dl = document.getElementById('door-wall-label');
  var wl = document.getElementById('window-wall-label');
  if (dl) dl.textContent = 'Wall '+(doorWallIdx+1);
  if (wl) wl.textContent = 'Wall '+(windowWallIdx+1);
  // Rebuild open dropdown if any
  if (document.querySelector('.wall-dropdown-list.open')) buildWallDropdowns();
}

function addOpening(type) {
  var wi  = (type==='door' ? doorWallIdx : windowWallIdx) % corners.length;
  var A   = corners[wi], B = corners[(wi+1)%corners.length];
  var len = dist(A,B);
  var w, h, sill=0, pos;
  if (type==='door') {
    w=parseFloat(document.getElementById('doorW').value);
    h=parseFloat(document.getElementById('doorH').value);
    pos=parseFloat(document.getElementById('doorPos').value)/100;
  } else {
    w=parseFloat(document.getElementById('winW').value);
    h=parseFloat(document.getElementById('winH').value);
    sill=parseFloat(document.getElementById('winSill').value);
    pos=parseFloat(document.getElementById('winPos').value)/100;
  }
  if (w >= len) { alert('Opening wider than wall!'); return; }
  openings.push({type:type,wallIdx:wi,width:w,height:h,sill:sill,position:pos,id:Date.now()});
  renderOpeningsList(); draw2D();
  if (currentView==='3d') buildRoom3D();
}

function removeOpening(id) {
  openings=openings.filter(function(o){return o.id!==id;});
  renderOpeningsList(); draw2D();
  if (currentView==='3d') buildRoom3D();
}

function renderOpeningsList() {
  var el=document.getElementById('openings-list');
  if (!openings.length){el.innerHTML='<span style="font-size:11px;color:var(--muted)">None yet.</span>';return;}
  el.innerHTML=openings.map(function(op){
    return '<div style="display:flex;align-items:center;justify-content:space-between;padding:5px 7px;background:var(--panel2);border:1px solid var(--border);border-radius:3px;margin-bottom:5px;font-size:11px;">'
      +'<span style="color:'+(op.type==='door'?'var(--accent)':'var(--accent2)')+'">■</span>'
      +'<span style="flex:1;padding:0 7px;color:var(--text);">'+op.type+' W'+(op.wallIdx+1)+' '+op.width.toFixed(1)+'m</span>'
      +'<button onclick="removeOpening('+op.id+')" style="background:none;border:none;color:var(--red);cursor:pointer;font-size:15px;padding:0 3px;">×</button>'
      +'</div>';
  }).join('');
}

function renderInnerWallsList() {
  var el=document.getElementById('inner-walls-list');
  if (!innerWalls.length){el.innerHTML='<span style="font-size:11px;color:var(--muted)">None yet.</span>';return;}
  el.innerHTML=innerWalls.map(function(iw,i){
    return '<div style="display:flex;align-items:center;justify-content:space-between;padding:5px 7px;background:var(--panel2);border:1px solid var(--border);border-radius:3px;margin-bottom:5px;font-size:11px;">'
      +'<span style="color:var(--muted)">Wall '+dist({x:iw.ax,y:iw.ay},{x:iw.bx,y:iw.by}).toFixed(1)+'m</span>'
      +'<button onclick="removeInnerWall('+i+')" style="background:none;border:none;color:var(--red);cursor:pointer;font-size:15px;padding:0 3px;">×</button>'
      +'</div>';
  }).join('');
}

function removeInnerWall(idx) {
  innerWalls.splice(idx,1);
  renderInnerWallsList(); draw2D();
  if (currentView==='3d') buildRoom3D();
}

// ================================================
// SURFACES
// ================================================
var PALETTES = {
  plain:    ['#f0ede8','#e8e4dc','#d6cfc4','#c4bdb2','#f5f0e8','#e8d8c4','#d4c4b0','#b8a090','#c8d4c0','#b0c4b8','#98b0a8','#8090a0'],
  wood:     ['#c8b89a','#b89870','#a07848','#8B6914','#d4b87c','#c8a050','#a08040','#786030','#9a7860','#7a6050','#6a5040','#5a4030'],
  tile:     ['#e8e4e0','#d4d0cc','#c8c0b8','#e0d8d0','#e8ddd0','#d8c8b8','#c8b8a8','#f0e8e0','#d0e8e0','#c0d8d8','#b0c8c8','#98b8b8'],
  brick:    ['#b5614a','#a05040','#c87050','#d48060','#8c4030','#a05038','#b86040','#c87050','#d48850','#c07040','#b06030','#a05028'],
  concrete: ['#9a9890','#888680','#787670','#686660','#aaaaa0','#909088','#808078','#706e68','#a0a898','#909888','#808878','#707868'],
};

function updateSwatches() {
  var mat=document.getElementById('mat-type').value;
  document.getElementById('swatch-grid').innerHTML=PALETTES[mat].map(function(c){
    return '<div class="swatch '+(c===selectedColor?'selected':'')+'" data-texture="'+mat+'" style="--c:'+c+';background-color:'+c+';" onclick="selectSwatch(\''+c+'\',this)"></div>';
  }).join('');
}

function selectSwatch(color, el) {
  document.querySelectorAll('.swatch').forEach(function(s){s.classList.remove('selected');});
  el.classList.add('selected'); selectedColor=color;
  document.getElementById('custom-color').value=color;
}
function selectCustomColor(color) {
  document.querySelectorAll('.swatch').forEach(function(s){s.classList.remove('selected');});
  selectedColor=color;
}

function selectSurface(surf, btn) {
  activeSurface=surf;
  document.querySelectorAll('#tab-surfaces .wall-btn').forEach(function(b){b.classList.remove('active');});
  if (btn) btn.classList.add('active');
  var ref=surf==='all-walls'?surfaces['wall-0']:surfaces[surf];
  if (ref){
    document.getElementById('mat-type').value=ref.material;
    document.getElementById('roughness').value=ref.roughness;
    selectedColor=ref.color;
    document.getElementById('custom-color').value=ref.color;
    updateSwatches();
  }
}

function applyCurrentSurface() {
  var mat=document.getElementById('mat-type').value;
  var rgh=parseFloat(document.getElementById('roughness').value);
  var targets=activeSurface==='all-walls'
    ? Object.keys(surfaces).filter(function(k){return k.startsWith('wall-');})
    : [activeSurface];
  targets.forEach(function(t){surfaces[t]={color:selectedColor,material:mat,roughness:rgh};});
  updateSurfaceList(); draw2D();
  if (currentView==='3d') buildRoom3D();
}

function applyToAll() {
  var mat=document.getElementById('mat-type').value, rgh=parseFloat(document.getElementById('roughness').value);
  Object.keys(surfaces).filter(function(k){return k.startsWith('wall-');}).forEach(function(t){
    surfaces[t]={color:selectedColor,material:mat,roughness:rgh};
  });
  updateSurfaceList(); draw2D();
  if (currentView==='3d') buildRoom3D();
}

// ================================================
// FURNITURE CATALOGUE
// ================================================
var CATALOGUE = {
  bathroom: [
    {type:'toilet',      label:'Toilet',      w:0.38, d:0.65},
    {type:'sink',        label:'Sink',        w:0.50, d:0.40},
    {type:'bath',        label:'Bathtub',     w:0.75, d:1.70},
    {type:'shower',      label:'Shower',      w:0.90, d:0.90},
  ],
  kitchen: [
    {type:'base-unit',   label:'Base Unit',   w:0.60, d:0.60},
    {type:'island',      label:'Island',      w:1.20, d:0.80},
    {type:'fridge',      label:'Fridge',      w:0.70, d:0.70},
    {type:'oven',        label:'Oven/Hob',    w:0.60, d:0.60},
    {type:'sink',        label:'Kitchen Sink',w:0.60, d:0.50},
    {type:'dining-table',label:'Table',       w:1.00, d:0.80},
  ],
  living: [
    {type:'sofa',        label:'Sofa',        w:2.20, d:0.90},
    {type:'armchair',    label:'Armchair',    w:0.85, d:0.85},
    {type:'dining-table',label:'Table',       w:1.20, d:0.80},
    {type:'desk',        label:'Desk',        w:1.40, d:0.70},
  ],
  bedroom: [
    {type:'bed-double',  label:'Double Bed',  w:1.60, d:2.00},
    {type:'bed-single',  label:'Single Bed',  w:0.90, d:2.00},
    {type:'wardrobe',    label:'Wardrobe',    w:1.80, d:0.60},
    {type:'desk',        label:'Desk',        w:1.20, d:0.60},
  ],
};

var FURN_ICONS = {
  toilet:'🚽', sink:'🚰', bath:'🛁', shower:'🚿',
  'base-unit':'🗄️', island:'▭', fridge:'🧊', oven:'🍳',
  sofa:'🛋️', armchair:'💺', 'dining-table':'⬤', desk:'🪑',
  'bed-double':'🛏️', 'bed-single':'🛏️', wardrobe:'🚪',
  'island':'▬', 'sink':'🚰',
};

function setRoomType(type, btn) {
  roomType=type;
  document.querySelectorAll('.room-type-btn').forEach(function(b){b.classList.remove('active');});
  btn.classList.add('active');
  renderFurnCatalogue();
}

function renderFurnCatalogue() {
  var items=CATALOGUE[roomType]||[];
  document.getElementById('furn-grid').innerHTML=items.map(function(item){
    return '<div class="furn-item" onclick="addFurniture(\''+item.type+'\',\''+item.label+'\','+item.w+','+item.d+')">'
      +'<span class="furn-icon">'+(FURN_ICONS[item.type]||'▪')+'</span>'
      +'<span class="furn-label">'+item.label+'</span>'
      +'</div>';
  }).join('');
}

function addFurniture(type, label, w, d) {
  // Place near centre
  var bounds=getBounds();
  furniture.push({type:type, label:label, w:w, d:d,
    x: (bounds.minX+bounds.maxX)/2, y: (bounds.minY+bounds.maxY)/2,
    rot:0, id:Date.now()});
  renderFurnList(); draw2D();
}

function renderFurnList() {
  var el=document.getElementById('furn-list');
  if (!furniture.length){el.innerHTML='<span style="font-size:11px;color:var(--muted)">None placed.</span>';return;}
  el.innerHTML=furniture.map(function(f){
    return '<div style="display:flex;align-items:center;justify-content:space-between;padding:5px 7px;background:var(--panel2);border:1px solid var(--border);border-radius:3px;margin-bottom:5px;font-size:11px;cursor:pointer;" onclick="selectFurn('+f.id+')">'
      +'<span style="color:var(--text)">'+f.label+'</span>'
      +'<button onclick="event.stopPropagation();removeFurn('+f.id+')" style="background:none;border:none;color:var(--red);cursor:pointer;font-size:14px;padding:0 3px;">×</button>'
      +'</div>';
  }).join('');
}

function selectFurn(id) { selectedFurnId=id; draw2D(); }
function removeFurn(id) {
  furniture=furniture.filter(function(f){return f.id!==id;});
  if (selectedFurnId===id) selectedFurnId=null;
  renderFurnList(); draw2D();
}

// ================================================
// 3D ENGINE
// ================================================
var renderer3d=null, scene3d=null, camera3d=null, roomGroup=null;
var isOrbiting=false, orbitStart={x:0,y:0};
var isPan3d=false, pan3dStart={x:0,y:0};
var spherical={theta:0.8, phi:0.65, radius:12};
var animRunning=false;
var outerWallMeshes=[];  // [{mesh, outwardNormal (THREE.Vector3)}]

function hexToColor(hex){ return new THREE.Color(parseInt(hex.replace('#',''),16)); }
function makeMat(surf) {
  return new THREE.MeshStandardMaterial({
    color:hexToColor(surf.color), roughness:surf.roughness, metalness:0,
    side:THREE.FrontSide, transparent:true, opacity:1.0,
  });
}

function init3D() {
  var container=document.getElementById('canvas3d');
  var W=container.clientWidth, H=container.clientHeight;
  renderer3d=new THREE.WebGLRenderer({antialias:true});
  renderer3d.setSize(W,H);
  renderer3d.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer3d.shadowMap.enabled=true;
  renderer3d.shadowMap.type=THREE.PCFSoftShadowMap;
  renderer3d.toneMapping=THREE.ACESFilmicToneMapping;
  renderer3d.toneMappingExposure=1.1;
  container.appendChild(renderer3d.domElement);

  scene3d=new THREE.Scene();
  scene3d.background=new THREE.Color(0xd8e4ec);
  scene3d.fog=new THREE.FogExp2(0xd8e4ec, 0.018);

  camera3d=new THREE.PerspectiveCamera(55,W/H,0.1,100);

  scene3d.add(new THREE.AmbientLight(0xfff5e0,0.5));
  var sun=new THREE.DirectionalLight(0xffe8b0,1.4);
  sun.position.set(6,9,5); sun.castShadow=true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.near=0.1; sun.shadow.camera.far=50;
  sun.shadow.camera.left=-15; sun.shadow.camera.right=15;
  sun.shadow.camera.top=15;   sun.shadow.camera.bottom=-15;
  scene3d.add(sun);
  var fill=new THREE.PointLight(0xe0f0ff,0.3,25);
  fill.position.set(-5,3,-5); scene3d.add(fill);

  setupOrbit3D();
  buildRoom3D();
  initCompass3D();
  startAnimate3D();
}

// Polygon winding: positive = CCW in standard math coords
// In canvas/world coords Y increases downward, so CCW visually = negative shoelace
function polyWindingSign() {
  var s = 0, n = corners.length;
  for (var i = 0; i < n; i++) {
    var j = (i+1)%n;
    s += (corners[j].x - corners[i].x) * (corners[j].y + corners[i].y);
  }
  return s > 0 ? 1 : -1; // 1 = CW in screen space (Y-down), -1 = CCW
}

// Simple ear-clip triangulation for a polygon given as THREE.Vector2 array
// Returns flat index array for BufferGeometry.setIndex
function triangulatePolygon(pts) {
  var n = pts.length;
  if (n < 3) return [];
  if (n === 3) return [0, 1, 2];

  // Compute signed area to determine winding
  var signedArea = 0;
  for (var i = 0; i < n; i++) {
    var j = (i+1)%n;
    signedArea += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
  }
  var isCCW = signedArea > 0;

  var indices = [];
  var remaining = [];
  for (var k = 0; k < n; k++) remaining.push(k);

  var safety = 0;
  while (remaining.length > 3 && safety++ < n * n * 2) {
    var found = false;
    var len2 = remaining.length;
    for (var i = 0; i < len2; i++) {
      var prev = remaining[(i - 1 + len2) % len2];
      var curr = remaining[i];
      var next = remaining[(i + 1) % len2];
      var a = pts[prev], b = pts[curr], c = pts[next];
      // Cross product: positive = CCW turn at b
      var cross = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
      // For CCW polygon, ear has positive cross; for CW, negative
      var isConvex = isCCW ? (cross > 0) : (cross < 0);
      if (!isConvex) continue;
      // Check no other point is inside this triangle
      var inside = false;
      for (var j = 0; j < len2; j++) {
        var idx = remaining[j];
        if (idx === prev || idx === curr || idx === next) continue;
        if (pointInTriangle(pts[idx], a, b, c)) { inside = true; break; }
      }
      if (!inside) {
        indices.push(prev, curr, next);
        remaining.splice(i, 1);
        found = true;
        break;
      }
    }
    if (!found) break; // degenerate, bail
  }
  if (remaining.length === 3) indices.push(remaining[0], remaining[1], remaining[2]);
  return indices;
}
function pointInTriangle(p, a, b, c) {
  var d1=(p.x-b.x)*(a.y-b.y)-(a.x-b.x)*(p.y-b.y);
  var d2=(p.x-c.x)*(b.y-c.y)-(b.x-c.x)*(p.y-c.y);
  var d3=(p.x-a.x)*(c.y-a.y)-(c.x-a.x)*(p.y-a.y);
  var hn=(d1<0)||(d2<0)||(d3<0), hp=(d1>0)||(d2>0)||(d3>0);
  return !(hn&&hp);
}

function buildRoom3D() {
  if (!scene3d) return;
  if (roomGroup) {
    roomGroup.traverse(function(o){
      if (o.geometry) o.geometry.dispose();
      if (o.material) {
        if (Array.isArray(o.material)) o.material.forEach(function(m){m.dispose();});
        else o.material.dispose();
      }
    });
    scene3d.remove(roomGroup);
  }
  // Clear any stray children not in roomGroup
  while (scene3d.children.length > 3) { // keep ambient, sun, fill lights
    var last = scene3d.children[scene3d.children.length - 1];
    if (last.isLight) break;
    scene3d.remove(last);
  }
  roomGroup = null;
  roomGroup=new THREE.Group();
  outerWallMeshes=[];
  ensureWallSurfaces();

  var H=H_CEIL;

  // Use world coordinates directly, offset to centre scene at 0,0
  var bounds=getBounds();
  var cx=(bounds.minX+bounds.maxX)/2, cy=(bounds.minY+bounds.maxY)/2;
  // Map: world X → Three X,  world Y → Three -Z  (standard top-down: Y increases downward on screen = south = +Z in Three)
  // To avoid the Shape rotation mirror bug we build floor/ceiling as BufferGeometry in XZ directly
  function w2t(wx, wy) { return {x: wx-cx, z: -(wy-cy)}; }  // world → three XZ

  // Floor via BufferGeometry (avoids ShapeGeometry rotation flip)
  var floorPts = corners.map(function(c){ var t=w2t(c.x,c.y); return new THREE.Vector2(t.x, t.z); });
  var floorShape = new THREE.Shape(floorPts);
  var floorGeo = new THREE.ShapeGeometry(floorShape);
  // ShapeGeometry is in XY; we need XZ → rotate around X
  // But negate Z in shape coords first so rotation goes right direction:
  // Actually: build vertices manually as a flat XZ mesh
  var floorVerts = [];
  var indices = [];
  floorPts.forEach(function(p){ floorVerts.push(p.x, 0, p.y); });
  // Simple ear-clip triangulation for convex/concave polygon
  var triIndices = triangulatePolygon(floorPts);
  var flatFloorGeo = new THREE.BufferGeometry();
  var posArr = new Float32Array(floorVerts);
  flatFloorGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
  flatFloorGeo.setIndex(triIndices);
  flatFloorGeo.computeVertexNormals();
  var floor = new THREE.Mesh(flatFloorGeo, makeMat(surfaces.floor));
  floor.receiveShadow = true;
  roomGroup.add(floor);

  // Ceiling — same verts, flipped normal, at height H
  var ceilVerts = [];
  floorPts.forEach(function(p){ ceilVerts.push(p.x, H, p.y); });
  var flatCeilGeo = new THREE.BufferGeometry();
  flatCeilGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ceilVerts), 3));
  flatCeilGeo.setIndex(triIndices.slice().reverse());
  flatCeilGeo.computeVertexNormals();
  var ceil = new THREE.Mesh(flatCeilGeo, makeMat(surfaces.ceiling));
  roomGroup.add(ceil);

  // Walls — one per edge, using w2t coordinates
  var hovWallMesh = null; // for green highlight
  for (var i=0;i<corners.length;i++) {
    var A=w2t(corners[i].x, corners[i].y), B=w2t(corners[(i+1)%corners.length].x, corners[(i+1)%corners.length].y);
    var dx=B.x-A.x, dz=B.z-A.z;
    var len=Math.sqrt(dx*dx+dz*dz);
    if (len<0.01) continue;

    var isHovered = (i === hoveredWallIdx);
    var wsurf=surfaces['wall-'+i]||surfaces['wall-0'];
    var ops=openings.filter(function(o){return o.wallIdx===i;});
    var rotY = -Math.atan2(dz, dx);

    var wallMat = makeMat(wsurf);
    if (isHovered) { wallMat = wallMat.clone(); wallMat.color.set(0x5fcf80); wallMat.emissive.set(0x1a4a20); }

    if (ops.length===0) {
      var wGeo=new THREE.PlaneGeometry(len,H);
      var wMesh=new THREE.Mesh(wGeo, wallMat);
      wMesh.position.set((A.x+B.x)/2, H/2, (A.z+B.z)/2);
      wMesh.rotation.y=rotY;
      wMesh.receiveShadow=true;
      roomGroup.add(wMesh);
      // Outward normal: perpendicular to wall, pointing AWAY from room centroid (0,0 in Three space)
      var nx = -dz/len, nz2 = dx/len;
      // Flip if normal points TOWARD centroid: dot(normal, mid) > 0 means pointing away from origin
      // We want it pointing AWAY, so flip when it points TOWARD (dot < 0)
      var midX=(A.x+B.x)/2, midZ=(A.z+B.z)/2;
      if (nx*midX + nz2*midZ < 0) { nx=-nx; nz2=-nz2; }
      outerWallMeshes.push({mesh:wMesh, normal:new THREE.Vector3(nx,0,nz2), wallIdx:i});
    } else {
      var wShape2=new THREE.Shape();
      wShape2.moveTo(-len/2,0); wShape2.lineTo(len/2,0);
      wShape2.lineTo(len/2,H); wShape2.lineTo(-len/2,H); wShape2.closePath();

      ops.forEach(function(op){
        var maxOff=len-op.width;
        var off=Math.max(0,Math.min(maxOff, op.position*len - op.width/2));
        var hx=-len/2+off, hy=op.sill||0;
        var hole=new THREE.Path();
        hole.moveTo(hx,hy); hole.lineTo(hx+op.width,hy);
        hole.lineTo(hx+op.width,hy+op.height); hole.lineTo(hx,hy+op.height);
        hole.closePath();
        wShape2.holes.push(hole);

        if (op.type==='window') {
          var gGeo=new THREE.PlaneGeometry(op.width-0.04,op.height-0.04);
          var gMat=new THREE.MeshStandardMaterial({color:0x88bbdd,transparent:true,opacity:0.22,roughness:0.05,side:THREE.DoubleSide});
          var gMesh=new THREE.Mesh(gGeo,gMat);
          var offFrac=(off+op.width/2)/len;
          gMesh.position.set(A.x+(B.x-A.x)*offFrac, (hy+op.height/2), A.z+(B.z-A.z)*offFrac);
          gMesh.rotation.y=rotY; roomGroup.add(gMesh);
        }
      });

      var sGeo=new THREE.ShapeGeometry(wShape2,4);
      var sMesh=new THREE.Mesh(sGeo, wallMat);
      sMesh.position.set((A.x+B.x)/2, 0, (A.z+B.z)/2);
      sMesh.rotation.y=rotY;
      sMesh.receiveShadow=true;
      roomGroup.add(sMesh);
      var nx3=-dz/len, nz3=dx/len;
      var midX3=(A.x+B.x)/2, midZ3=(A.z+B.z)/2;
      if (nx3*midX3 + nz3*midZ3 < 0) { nx3=-nx3; nz3=-nz3; }
      outerWallMeshes.push({mesh:sMesh, normal:new THREE.Vector3(nx3,0,nz3), wallIdx:i});
    }
  }

  // Inner walls in 3D
  innerWalls.forEach(function(iw){
    var a=w2t(iw.ax,iw.ay), b=w2t(iw.bx,iw.by);
    var dx=b.x-a.x, dz=b.z-a.z, len=Math.sqrt(dx*dx+dz*dz);
    if (len<0.01) return;
    var iGeo=new THREE.PlaneGeometry(len,H);
    var iMat=new THREE.MeshStandardMaterial({color:hexToColor('#e8e4dc'),roughness:0.85,side:THREE.DoubleSide});
    var iMesh=new THREE.Mesh(iGeo,iMat);
    iMesh.position.set((a.x+b.x)/2, H/2, (a.z+b.z)/2);
    iMesh.rotation.y=-Math.atan2(dz,dx);
    iMesh.receiveShadow=true;
    roomGroup.add(iMesh);
  });

  // Furniture in 3D
  furniture.forEach(function(f){
    var ft=w2t(f.x,f.y);
    var fGeo=new THREE.BoxGeometry(f.w, 0.75, f.d);
    var fMat=new THREE.MeshStandardMaterial({color:0x2a2a28,roughness:0.7,metalness:0.05});
    var fMesh=new THREE.Mesh(fGeo,fMat);
    fMesh.position.set(ft.x, 0.375, ft.z);
    fMesh.rotation.y=f.rot*Math.PI/2;
    fMesh.castShadow=true; fMesh.receiveShadow=true;
    roomGroup.add(fMesh);
  });

  scene3d.add(roomGroup);
  updateCameraOrbit();
}

function updateCameraOrbit() {
  if (!camera3d) return;
  var t=spherical.theta, p=spherical.phi, r=spherical.radius;
  camera3d.position.set(r*Math.sin(p)*Math.sin(t), r*Math.cos(p), r*Math.sin(p)*Math.cos(t));
  camera3d.lookAt(0, H_CEIL*0.4, 0);
}

function setupOrbit3D() {
  var cont=document.getElementById('canvas3d');
  cont.addEventListener('mousedown',function(e){
    if(e.button===0){isOrbiting=true;orbitStart={x:e.clientX,y:e.clientY};}
    if(e.button===2){isPan3d=true;pan3dStart={x:e.clientX,y:e.clientY};}
  });
  window.addEventListener('mousemove',function(e){
    if(isOrbiting){
      spherical.theta-=(e.clientX-orbitStart.x)*0.005;
      spherical.phi=Math.max(0.08,Math.min(Math.PI-0.08,spherical.phi+(e.clientY-orbitStart.y)*0.005));
      updateCameraOrbit(); orbitStart={x:e.clientX,y:e.clientY};
    }
    if(isPan3d){
      camera3d.position.y-=(e.clientY-pan3dStart.y)*0.012;
      pan3dStart={x:e.clientX,y:e.clientY};
    }
  });
  window.addEventListener('mouseup',function(){isOrbiting=false;isPan3d=false;});
  cont.addEventListener('wheel',function(e){
    spherical.radius=Math.max(2,Math.min(35,spherical.radius+e.deltaY*0.02));
    updateCameraOrbit();
  },{passive:true});
  cont.addEventListener('contextmenu',function(e){e.preventDefault();});
}

var compass3dCtx = null;
function initCompass3D() {
  var c = document.getElementById('compass3d');
  if (!c) return;
  c.width = 72; c.height = 72;
  compass3dCtx = c.getContext('2d');
}

function draw3DCompass() {
  var ctx2 = compass3dCtx;
  if (!ctx2 || !camera3d) return;
  var s = 72, cx = s/2, cy = s/2, r = 28;
  ctx2.clearRect(0, 0, s, s);

  // Background circle
  ctx2.beginPath(); ctx2.arc(cx, cy, r+4, 0, Math.PI*2);
  ctx2.fillStyle = 'rgba(220,232,240,0.88)';
  ctx2.fill();
  ctx2.strokeStyle = 'rgba(100,120,140,0.4)'; ctx2.lineWidth = 1;
  ctx2.stroke();

  // Camera azimuth from spherical.theta
  // theta=0 → camera looks from +Z (south), N is at top when theta=PI
  var azimuth = spherical.theta; // camera position angle around Y

  var dirs = [
    {label:'N', angle: 0,          color:'#c8a96e', bold:true},
    {label:'E', angle: Math.PI/2,  color:'#8a9aaa', bold:false},
    {label:'S', angle: Math.PI,    color:'#8a9aaa', bold:false},
    {label:'W', angle:-Math.PI/2,  color:'#8a9aaa', bold:false},
  ];

  dirs.forEach(function(d) {
    // Angle in screen: world direction relative to camera azimuth
    var screenAngle = d.angle - azimuth - Math.PI/2;
    var tx = cx + Math.cos(screenAngle) * r * 0.72;
    var ty = cy + Math.sin(screenAngle) * r * 0.72;
    ctx2.font = (d.bold ? 'bold ' : '') + '11px DM Sans';
    ctx2.fillStyle = d.color;
    ctx2.textAlign = 'center';
    ctx2.textBaseline = 'middle';
    ctx2.fillText(d.label, tx, ty);
  });

  // North arrow
  var nAngle = 0 - azimuth - Math.PI/2;
  var ax = cx + Math.cos(nAngle) * (r - 6);
  var ay = cy + Math.sin(nAngle) * (r - 6);
  var bx = cx - Math.cos(nAngle) * (r - 10);
  var by = cy - Math.sin(nAngle) * (r - 10);
  ctx2.beginPath(); ctx2.moveTo(cx, cy); ctx2.lineTo(ax, ay);
  ctx2.strokeStyle = '#c8a96e'; ctx2.lineWidth = 2.5; ctx2.lineCap = 'round';
  ctx2.stroke();
  ctx2.beginPath(); ctx2.moveTo(cx, cy); ctx2.lineTo(bx, by);
  ctx2.strokeStyle = 'rgba(100,120,140,0.5)'; ctx2.lineWidth = 1.5;
  ctx2.stroke();
  // Centre dot
  ctx2.beginPath(); ctx2.arc(cx, cy, 3, 0, Math.PI*2);
  ctx2.fillStyle = '#c8a96e'; ctx2.fill();
}

function startAnimate3D() {
  if (animRunning) return; animRunning=true;
  var _camDir=new THREE.Vector3();
  (function loop(){
    if (!animRunning) return;
    requestAnimationFrame(loop);
    // Per-wall camera-facing transparency
    if (camera3d && outerWallMeshes.length) {
      outerWallMeshes.forEach(function(w){
        // Use camera direction vs stored outward normal
        // outward normal points away from room interior
        // camera→wall centre vector
        _camDir.copy(camera3d.position).sub(w.mesh.position).normalize();
        var dot = _camDir.dot(w.normal);
        // dot > 0: camera is on the outside (outward side) → wall faces us → solid
        // dot < 0: camera is inside/behind → wall faces away → invisible
        var isHov = (w.wallIdx === hoveredWallIdx);
        if (isHov) {
          // Always show hovered wall as bright green regardless of camera angle
          w.mesh.material.opacity = 1.0;
          w.mesh.material.color.set(0x5fcf80);
          w.mesh.material.emissive.set(0x1a4a20);
        } else {
          // Reset colour in case it was previously hovered
          w.mesh.material.emissive.set(0x000000);
          if (dot > 0.1) {
            w.mesh.material.opacity = 1.0; // facing camera → fully solid
          } else {
            w.mesh.material.opacity = 0.0; // back to camera → completely invisible
          }
        }
      });
    }
    if (renderer3d&&scene3d&&camera3d) { renderer3d.render(scene3d,camera3d); draw3DCompass(); }
  })();
}

// ================================================
// VIEW / TOOL SWITCH
// ================================================
function switchView(v) {
  currentView=v;
  document.getElementById('btn2d').classList.toggle('active',v==='2d');
  document.getElementById('btn3d').classList.toggle('active',v==='3d');
  document.getElementById('view2d').style.display  = v==='2d'?'block':'none';
  document.getElementById('view3d').style.display  = v==='3d'?'block':'none';
  document.getElementById('toolbar2d').style.display= v==='2d'?'flex':'none';
  if (v==='3d') {
    if (!renderer3d) { setTimeout(function(){init3D();},30); }
    else {
      buildRoom3D();
      var cont=document.getElementById('canvas3d');
      renderer3d.setSize(cont.clientWidth,cont.clientHeight);
      camera3d.aspect=cont.clientWidth/cont.clientHeight;
      camera3d.updateProjectionMatrix();
      startAnimate3D();
    }
  } else { animRunning=false; resizeCanvas(); }
}

function switchTab(tab,btn) {
  document.querySelectorAll('.tab-pane').forEach(function(p){p.classList.remove('active');});
  document.querySelectorAll('.panel-tab').forEach(function(t){t.classList.remove('active');});
  document.getElementById('tab-'+tab).classList.add('active');
  btn.classList.add('active');
}

function setTool(t) {
  tool=t; wallDrawStart=null;
  document.querySelectorAll('.tool-btn[id^="tool-"]').forEach(function(b){b.classList.remove('active');});
  var el=document.getElementById('tool-'+t);
  if(el) el.classList.add('active');
  c2d.style.cursor= t==='pan'?'grab':t==='wall'?'crosshair':'default';
  document.getElementById('tool-info').textContent =
    t==='select' ? 'Drag corners to reshape · Drag furniture' :
    t==='pan'    ? 'Drag to pan' :
    t==='wall'   ? 'Click two points to draw inner wall · Esc to cancel' : '';
}

function toggleGrid() {
  showGrid=!showGrid;
  document.getElementById('tool-grid').textContent='Grid: '+(showGrid?'On':'Off');
  draw2D();
}

// ================================================
// 3D TOOLBAR (injected when switching to 3D)
// ================================================
function show3DToolbar() {
  var tb=document.getElementById('toolbar3d');
  if (!tb) {
    tb=document.createElement('div');
    tb.id='toolbar3d';
    tb.className='canvas-toolbar';
    tb.style.display='flex';
    tb.innerHTML='<button class="tool-btn" onclick="buildRoom3D()">Rebuild</button>'
      +'<span class="tool-info">Left-drag: orbit · Scroll: zoom · Right-drag: pan · Walls auto-transparent</span>';
    document.getElementById('view3d').prepend(tb);
  }
}

// ================================================
// RESIZE
// ================================================
window.addEventListener('resize',function(){
  if (currentView==='2d') resizeCanvas();
  if (renderer3d) {
    var cont=document.getElementById('canvas3d');
    renderer3d.setSize(cont.clientWidth,cont.clientHeight);
    camera3d.aspect=cont.clientWidth/cont.clientHeight;
    camera3d.updateProjectionMatrix();
  }
});

// ================================================
// INIT
// ================================================
window.addEventListener('DOMContentLoaded',function(){
  ensureWallSurfaces();
  resizeCanvas();
  updateSwatches();
  updateInfoPanel();
  renderFurnCatalogue();
  refreshWallDropdowns();

  // Override switchView to also show 3D toolbar
  var orig=switchView;
  switchView=function(v){
    orig(v);
    if(v==='3d') setTimeout(show3DToolbar, 60);
  };
});
</script>
</body>
</html>
